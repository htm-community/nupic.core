/* ----------------------------------------------------------------------
# Numenta Platform for Intelligent Computing (htm)
# Copyright (C) 2018, Numenta, Inc.  Unless you have an agreement
# with Numenta, Inc., for a separate license for this software code, the
# following terms and conditions apply:
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Affero Public License for more details.
#
# You should have received a copy of the GNU Affero Public License
# along with this program.  If not, see http://www.gnu.org/licenses.
#
# http://numenta.org/licenses/
#
# Author: David Keeney, Jan 2018
# ----------------------------------------------------------------------*/
// This is C++/CLI code that forms the API interface for C#.
// compile with: /LD /clr  

// Design approach:
//    wrapper the core classes (which are instatiated on the C++ heap) inside
//    CLI classes which are instatiated on the managed heap which implements garbage 
//    collection and is accessable as C# classes. Pointers to buffers on the managed
//    heap that are passed to the core are pinned so they cannot be moved by garbage collection.
//
//    Where it makes since the get/set functions were converted to properties.
//
//    All data in the wrapped core classes is automatically accessable to the C# classes
//    with appropreate data type conversions applied.
//
//    All data changed on the wrapper classes should be automatically reflected down into 
//    the core classes with appropreate data type conversions.  The core should not be aware 
//    that the client is using C#.
//
//    std::Exceptions generated by the core are converted to CLI exceptions at the language
//    interface.
//
//
//  How this works...
//  1) The using application starts by allocating a subclass of cs_Network that implements allocateRegionImpl().
//     That allocation function allows the engine to instantiate the plug-ins that are implemented in C#.
//
//  2) At the start of a session the using application must register all implementation plug-ins for 
//     any of the regions that it wants to use in a run. It does that by calling cs_Network::addRegion().
//     The generic on the call is the C# class being registered as the implementation for that region
//     and the name is the uneque name given to that region instance, and the nodeParams argument is a 
//     YAML encoded string providing the parameters for the region instance. It does this for each instance 
//     of a region it wants to use.
//
//  3) Set additional parameters on each region instance.
//
//  4) Specify the input/output connections between regions using the link() functions.
//
//  5) Then the using application then starts it running for N steps by calling run() of the subclass of cs_Network.
//      - Allocate instances of each region.
//      - Calls a static function createSpec() on each region implementation.
//      - Sets up the input/output connections for each region
//      - Calls compute on each region in the prescribed sequence.
//     At the end of N steps it returns back to the using application so it can regain control.
//
//  6) If the using application wants to later restart, it can save the current state of the run
//     by serializing the current state into a bundle by calling cs_Network::save(path) with an
//     argument that specifies where the saved bundle is to be placed.
//
//  7) To restart the saved session, start by again creating an instance of the C# subclass of cs_Network
//     passing in the path to the serialized bundle. This will restore everything to the the
//     run state that it was in at step 6.
//
//  https://msdn.microsoft.com/en-us/library/system.activator.createinstance(v=vs.110).aspx


#ifndef NTA_CS_ENGINE_HPP
#define NTA_CS_ENGINE_HPP
#pragma once


#include <cs_Tools.h>   // macros and conversion routines
#include <cs_Types.hpp>
#include <cs_Utils.hpp>

//using namespace std;  -- explicitly declare std:: types
using namespace System;

namespace htm_core_cs
{

  /*****
  ref class cs_Network;
  ref class cs_Region;
  ref class cs_Dimensions;
  ref class cs_Link;
  ref class cs_Spec;
  generic <typename T> ref class cs_Collection;
  generic <typename T> ref class cs_Input;
  generic <typename T> ref class cs_Output;
  ref class cs_InputSpec;
  ref class cs_OutputSpec;
  ref class cs_CommandSpec;
  ref class cs_ParameterSpec;
  ref class cs_InputSpec;
  ref class cs_OutputSpec;
  ref class cs_CommandSpec;
  ref class cs_ParameterSpec;
  ref class cs_Timer;
  ref class cs_Dimensions;
  ref class cs_BundleIO;
  generic <typename T> ref class cs_Array;
  generic <typename T> ref class cs_ArrayRef;
  class ArrayCS;
  ref class cs_Timer;
  *****/




  //////////////////////////////////////
  //        Network
  //////////////////////////////////////
  // NOTE: this class must be subclassed by a class in C# which will implement allocateRegionImpl().
  //       This is required because only the C# subclass will have visability into the classes that
  //       locally implement a plugin (a subclass of cs_RegionImpl).  When the engine needs to instanitate 
  //       one of these implementations while processing the run() method it will call back to 
  //       allocateRegionImpl() to get an instance of that cs_RegionImpl subclass.

  ref class cs_Network abstract
  {
  internal:
    cs_Network(htm::Network* n) {
      if (!n) { throw gcnew OutOfMemoryException("Initializing cs_Network"); }
      network_ = n;
    }
    htm::Network* getUnmanaged() { return network_; }

  public:
    cs_Network() {
      network_ = new htm::Network();
      if (!network_) { throw gcnew OutOfMemoryException("Initializing cs_Network"); }
    }
    cs_Network(System::String^ path) {  // creates everything from serialized bundle
      network_ = new htm::Network(StringToUTF8(path));
      if (!network_) { throw gcnew OutOfMemoryException("Initializing cs_Network"); }
    }
    virtual
      ~cs_Network() { if (network_) { delete network_; network_ = nullptr; } }
    !cs_Network() { if (network_) { delete network_; network_ = nullptr; } }


    // nodeType is the fully qualified type name of the class that implements the plugin for the region.
    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/typeof
    // The C# subclass should implement this as:
    //     public cs_Region addRegion<T>(string regionName, string nodeParams) 
    //     {
    //         return addRegion(regionName, typeof(T).AssemblyQualifiedName, nodeParams);
    //     }
    //
    generic <typename T>
    virtual cs_Region^ addRegion<T>(String^ regionName, String^ nodeParams) {
      String^ nodeType = typeid(T).AssemblyQualifiedName;
      return this->addRegion(regionName, nodeType, nodeParams);
    }
    virtual cs_Region^ addRegion(String^ regionName, String^ nodeType, String^ nodeParams) {
      if (nodeType->IndexOf(",") > 0) {
        // must be a C# implemented plugin, rather than a built-in CPP plugin.
        CsRegisteredRegionImpl* registered = new CsRegisteredRegionImpl(this, nodeType);
        Region::registerCPPRegion(StringToUTF8(nodeType), registered);
      }
      htm::Region *region = network_->addRegion(StringToUTF8(regionName), StringToUTF8(nodeType), StringToUTF8(nodeParams));
      return gcnew cs_Region(region, this, false);
    }


    // internal
    //virtual cs_Region^ addRegionFromBundle(String^ name, String^ nodeType, cs_Dimensions^ dimensions, String^ bundlePath, String^ label) {
    //  htm::Region* region = network_->addRegionFromBundle(StringToUTF8(name), StringToUTF8(nodeType), *(dimensions->getUnmanaged()), StringToUTF8(bundlePath), StringToUTF8(label));
    //  return gcnew cs_Region(region, this, false);
    //}

    virtual  void removeRegion(String^ name) { network_->removeRegion(StringToUTF8(name)); }


    virtual void link(String^ srcName, String^ destName, String^ linkType, String^ linkParams, String^ srcOutput, String^  destInput, System::UInt64 propagationDelay) {
      network_->link(StringToUTF8(srcName), StringToUTF8(destName), StringToUTF8(linkType), StringToUTF8(linkParams),
        StringToUTF8(srcOutput), StringToUTF8(destInput), propagationDelay);
    }
    virtual void link(String^ srcName, String^ destName, String^ linkType, String^ linkParams, String^ srcOutput, String^  destInput) {
      network_->link(StringToUTF8(srcName), StringToUTF8(destName), StringToUTF8(linkType), StringToUTF8(linkParams),
        StringToUTF8(srcOutput), StringToUTF8(destInput), 0);
    }
    virtual void link(String^ srcName, String^ destName, String^ linkType, String^ linkParams, String^ srcOutput) {
      network_->link(StringToUTF8(srcName), StringToUTF8(destName), StringToUTF8(linkType), StringToUTF8(linkParams),
        StringToUTF8(srcOutput), "", 0);
    }
    virtual void link(String^ srcName, String^ destName, String^ linkType, String^ linkParams) {
      network_->link(StringToUTF8(srcName), StringToUTF8(destName), StringToUTF8(linkType), StringToUTF8(linkParams),
        "", "", 0);
    }

    virtual System::Collections::Generic::Dictionary<System::String^, cs_Region^>^ getRegions() {
      System::Collections::Generic::Dictionary<System::String^, cs_Region^>^ container = gcnew System::Collections::Generic::Dictionary<System::String^, cs_Region^>();
      const htm::Collection<htm::Region*>& lst = network_->getRegions();
      size_t len = lst.getCount();
      for (size_t i = 0; i < len; i++) {
        const std::pair<std::string, htm::Region*>& p = lst.getByIndex(i);
        cs_Region^ r = gcnew cs_Region(p.second, this, false);
        container->Add(UTF8ToString(p.first), r);
      }
      return container;
    }

    virtual System::Collections::Generic::Dictionary<System::String^, cs_Link^>^ getLinks() {
      System::Collections::Generic::Dictionary<System::String^, cs_Link^>^ container = gcnew System::Collections::Generic::Dictionary<System::String^, cs_Link^>();
      htm::Collection<htm::Link*>& lst = network_->getLinks();
      size_t len = lst.getCount();
      for (size_t i = 0; i < len; i++) {
        const std::pair<std::string, htm::Link*>& p = lst.getByIndex(i);
        cs_Link^ r = gcnew cs_Link(p.second);
        container->Add(UTF8ToString(p.first), r);
      }
      return container;
    }
    virtual property array<System::UInt32>^ phases[String^]{
      void set(String^ name, array<System::UInt32>^ phases) {
      std::set<System::UInt32> lst;
      for each(System::UInt32 phase in phases) { lst.insert(phase); }
      network_->setPhases(StringToUTF8(name), lst);  // the list will be copied
    }
    array<System::UInt32>^ get(String^ name) {
      std::set<System::UInt32> lst = network_->getPhases(StringToUTF8(name));
      array< System::UInt32 >^ container = gcnew array< System::UInt32 >((int)lst.size());
      int i = 0;
      for (std::set<System::UInt32>::iterator it = lst.begin(); it != lst.end(); ++it) {
        container[i++] = *it;
      }
      return container;
    }
    }
      virtual property System::UInt32 minPhase {
      System::UInt32 get() { return network_->getMinPhase(); }
    }
    virtual property System::UInt32 maxPhase {
      System::UInt32 get() { return network_->getMaxPhase(); }
    }
    virtual property System::UInt32 minEnabledPhase {
      System::UInt32 get() { return network_->getMinEnabledPhase(); }
      void set(System::UInt32 minPhase) { network_->setMinEnabledPhase(minPhase); }
    }
    virtual property System::UInt32 maxEnabledPhase {
      System::UInt32 get() { return network_->getMaxEnabledPhase(); }
      void set(System::UInt32 minPhase) { network_->setMaxEnabledPhase(maxPhase); }
    }

    virtual void initialize() { network_->initialize(); }
    virtual void save(String^ name) { network_->save(StringToUTF8(name)); }
    virtual void run(System::Int32 n) { network_->run(n); }
    virtual void enableProfiling() { network_->enableProfiling(); }
    virtual void disableProfiling() { network_->disableProfiling(); }
    virtual void resetProfiling() { network_->resetProfiling(); }

    //generic <typename T> static void registerCsRegion(System::String^ name) { cs_Region::registerCsRegion<T>(name); }
    //static void unregisterCsRegion(System::String^ name) { htm::Network::unregisterCPPRegion(StringToUTF8(name)); }


    // Implemented by the C# subclass of cs_Network.  Called by the engine to instantiate an instance of a region Impl.
    // The nodeType argument comes from the genaric passed to addRegion().  It is expected to be something like
    //    Classname, ExampleAssembly, Version=1.0.0.0, Culture=en, PublicKeyToken=a5d015c7d5a0b012
    // or Classname, ExampleAssembly
    //
    // It will do this by using:    
    //    C#
    //    public allocateRegionImpl(String nodeType) 
    //    {
    //      var array type = nodeType.Split(new Char[] {','}, 2);
    //      return dynamic_cast<cs_RegionImpl^> Activator.CreateInstance(Trim(type[1]), Trim(type[0]));
    //    }
    // https://msdn.microsoft.com/en-us/library/d133hta4(v=vs.110).aspx
    //
    virtual cs_RegionImpl^ allocateRegionImpl(System::String^ nodeType) abstract;


  private:
    htm::Network *network_;
  };




  //////////////////////////////////////
  //        Region
  //////////////////////////////////////
  /* Managed C++ wrapper for the Region class.
  *  compile with: /LD /clr
  *
  * A region is a set of one or more "identical" nodes, implemented by a
  * RegionImpl "plugin".
  *
  * Class Hiearchy for Region
  *  cs_Region is a wrapper around Region for use with C#
  *  Region is wrapped by RegionImpl in RegionImplFactory.
  *
  *  GenericRegisteredRegionImpl  Base virtual class (as type for registration)
  *    RegisteredRegionImpl wraps RegionImpl (for C++ and C#)
  *          RegionImpl Created by RegionImplFactory.  All plugins have this as base class.
  *              PyRegion is a C++ subclass or RegionImpl that references a Python implimentation of a region
  *                  SPRegion is a Python subclass of PyRegion that wrappers the SpatialPooler implementations (sp_region.py)
  *                  TMRegion is a Python subclass of PyRegion that wrappers the Temporal Memory implementations (tm_region.py)
  *                  Python implemented Encoders, Classifiers, and other components subclass from PyRegion
  *
  *              CsRegion is a wrapper around RegionImpl as interface for C#
  *                  SPRegion.cs is a C# subclass of CsRegion that wrappers the C# SpatialPooler implementations (sp_region.cs)
  *                  TMRegion.cs is a C# subclass of CsRegion that wrappers the C# Temporal Memory implementations. (tm_region.cs)
  *
  *              CppRegion is a wrapper around RegionImpl as interface for Cpp client use (basically a passthrough)
  *                  SPRegion.cpp is a C++ subclass of CppRegion that wrappers the C++ SpatialPooler implementations (sp_region.cpp)
  *                  TMRegion.cpp is a C++ subclass of CppRegion that wrappers the Temporal Memory implementations.  (tp_region.cpp)
  *
  *              C++ core implemented Encoders, Classifiers, and other components that are part of the core, subclass directly from RegionImpl.
  */
  ref class cs_Region
  {
  internal:
    cs_Region(htm::Region *region, cs_Network^ network, Boolean own) {   // use cs_Network::addRegion() to create
      region_ = region; own_ = own; cs_network_ = network; 
    } 
    htm::Region* getUnmanged() { return region_; }

    generic <typename T>
      static void registerCsRegion<T>(System::String^ name) {     // to register a CPP class on behalf of CSharp
        RegisteredRegionImpl<T>* wrapper = new RegisteredRegionImpl<T>(StringToUTF8(name));
        typename_ = typeid(T)->Assembly.AssemblyQualifiedName;
        htm::Region::registerCPPRegion(StringToUTF8(name), wrapper);
      }
      static void unregisterCPPRegion(System::String^ name) { htm::Region::unregisterCPPRegion(StringToUTF8(name)); }


  public:
    cs_Region(String^ name, String^ nodeType, String^ nodeParams, cs_Network^ network) {
      region_ = new htm::Region(StringToUTF8(name), StringToUTF8(nodeType), StringToUTF8(nodeParams), network->getUnmanaged());
      cs_network_ = network;
      own_ = true;
    }
    virtual
      ~cs_Region() { if (own_) delete region_;  region_ = nullptr; }
    !cs_Region() { if (own_) delete region_;  region_ = nullptr; }

    property cs_Network^ network {
      cs_Network^ get() { return cs_network_; }
    }
    property System::String^ name {
      System::String^ get() { return UTF8ToString(region_->getName()); }
    }
    property cs_Dimensions^ dimensions {
      cs_Dimensions^ get() { const htm::Dimensions& dim = region_->getDimensions(); return gcnew cs_Dimensions(&dim); }
      void set(cs_Dimensions^ dimensions) { region_->setDimensions(*dimensions->getUnmanaged()); }
    }
    property System::String^ type {
      System::String^ get() { return UTF8ToString(region_->getType()); }
    }
    property const cs_Spec^ spec {
      const cs_Spec^  get() { return gcnew cs_Spec(region_->getSpec()); }
    }

    cs_Spec^ getSpecFromType(System::String^ nodeType) { return gcnew cs_Spec(region_->getSpecFromType(StringToUTF8(nodeType))); }


    generic <typename T>
      virtual T getParameter(String^ name) {
        if (typeid(T) == typeid(System::Int32)) { return region_->getParameterInt32(StringToUTF8(name)); }
        else if (typeid(T) == typeid(System::UInt32)) { return region_->getParameterUInt32(StringToUTF8(name)); }
        else if (typeid(T) == typeid(System::Int64)) { return region_->getParameterInt64(StringToUTF8(name)); }
        else if (typeid(T) == typeid(System::UInt64)) { return region_->getParameterUInt64(StringToUTF8(name)); }
        else if (typeid(T) == typeid(System::Single)) { return region_->getParameterReal32(StringToUTF8(name)); }
        else if (typeid(T) == typeid(System::Double)) { return region_->getParameterReal64(StringToUTF8(name)); }
        else if (typeid(T) == typeid(System::Boolean)) { return region_->getParameterBool(StringToUTF8(name)); }
        else if (typeid(T) == typeid(System::String^)) { return UTF8ToString(region_->getParameterString(StringToUTF8(name))); }
        else throw gcnew Exception("Invalid parameter type: " + typeid(T).name());
      }

      generic <typename T>
        virtual void setParameter(System::String^ name, T value) {
          if (typeid(T) == typeid(System::Int32)) { region_->setParameterInt32(StringToUTF8(name), value); }
          else if (typeid(T) == typeid(System::UInt32)) { region_->setParameterUInt32(StringToUTF8(name), value); }
          else if (typeid(T) == typeid(System::Int64)) { region_->setParameterInt64(StringToUTF8(name), value); }
          else if (typeid(T) == typeid(System::UInt64)) { region_->setParameterUInt64(StringToUTF8(name), value); }
          else if (typeid(T) == typeid(System::Single)) { region_->setParameterReal32(StringToUTF8(name), value); }
          else if (typeid(T) == typeid(System::Double)) { region_->setParameterReal64(StringToUTF8(name), value); }
          else if (typeid(T) == typeid(System::Boolean)) { region_->setParameterBool(StringToUTF8(name), value); }
          else if (typeid(T) == typeid(System::String^)) { region_->setParameterString(StringToUTF8(name), StringToUTF8(s)); }
          else throw gcnew Exception("Invalid parameter type: " + typeid(T).name());
        }

        //   virtual property array<T>^ parameterArray[String^ name] {
        generic <typename T>
          virtual array<T>^ getParameterArray(String^ name) { return ((ArrayCS*)region_->getParameterArray(StringToUTF8(name)))->getManaged(); }
          generic <typename T>
            virtual void setParameterArray(System::String^ name, array<T>^ arr) { region_->setParameterArray(StringToUTF8(name), new htm::ArrayCS<T>(arr)); }


            virtual property Boolean parameterShared[String^]{
              Boolean get(String^ name) { return region_->isParameterShared(StringToUTF8(name)); }
            }

              // internal, called by RegionImpl
              //virtual property cs_ArrayRef^ inputData[String^]{ cs_ArrayRef^ get(String^ inputName) { return gcnew cs_ArrayRef(region_->getInputData(StringToUTF8(inputName))); } }
              //virtual property cs_ArrayRef^ outputData[String^]{ cs_ArrayRef^ get(String^ outputName) { return gcnew cs_ArrayRef(region_->getOutputData(StringToUTF8(outputName))); } }
              //virtual property UInt64 inputCount[String^]{ UInt64 get(String^ inputName) { return region_->getInputCount(StringToUTF8(inputName)); } }
              //virtual property UInt64 outputCount[String^]{ UInt64 get(String^ outputName) { return region_->getOutputCount(StringToUTF8(outputName)); } }

              //void prepareInputs() { region_->prepareInputs(); }
              //void enable() { region_->enable(); }
              //void disable() { region_->disable(); }
              //System::String^ executeCommand(System::Collections::Generic::List<System::String^>^ args) { return UTF8ToString(region_->executeCommand(ListTovector<System::String^, std::string>(args))); }
              //void compute() { region_->compute(); }
              //void enableProfiling() { region_->enableProfiling(); }
              //void disableProfiling() { region_->disableProfiling(); }
              //void resetProfiling() { region_->resetProfiling(); }
              //virtual property cs_Timer^ computeTimer { cs_Timer^ get() { return gcnew cs_Timer(region_->getComputeTimer()); }}
              //virtual property cs_Timer^ executeTimer { cs_Timer^ get() { return gcnew cs_Timer(region_->getExecuteTimer()); }}

  private:
    // verboten
    cs_Region();
    cs_Region(cs_Region^ r);

    String^ typename_;   // Assembley qualified name of the C# object that implements the region.
    htm::Region* region_;
    cs_Network^ cs_network_;
    bool own_;

  };

}  // namespace htm_core_cs

namespace htm
{
  //////////////////////////////////////
  //        RegionImpl 
  //   wrappers:
  //        CsRegisteredRegionImpl  (Internal)
  //        CsBindRegion  (Internal)
  //        cs_RegionImpl  (External Base class)
  //
  //  RegionImpl is the "plugin" interface for HTM.
  //  There are three classes that implement RegionImpl for use with C#:
  //
  //  1) CsRegisteredRegionImpl which is used to register a class
  //     represents the type of a C# plug-in implementation.
  //
  //  2) CsBindRegion is a native C++ subclass of RegionImpl to implement virtual functions
  //     for the native C++ side and calls virtual functions on cs_RegionImpl which is the C# side.
  //
  //  3) cs_RegionImpl: managed wrapper around CsBindRegion for C# calling into C++.
  //     All C# Region implementations should subclass cs_RegionImpl.
  //
  //  
  //////////////////////////////////////
  private class CsRegisteredRegionImpl : public GenericRegisteredRegionImpl {
  public:
    CsRegisteredRegionImpl(htm_core_cs::cs_Network^ network, System::String^ nodename) { network_ = network; nodename_ = nodename; }

    ~CsRegisteredRegionImpl() {}

    // instatiation for initial run  (from RegionImplFactory->createRegionImpl() )
    virtual RegionImpl* createRegionImpl(const ValueMap& params, Region *region) override
    {
      // 1) instatiate the CsBindRegion which will also create the C# class <T> 
      // 2) Initialize with params from the ValueMap.
      // 3) return the CsBindRegion class (not the C# class)
      RegionImpl* impl = new CsBindRegion(network_, nodename_, params, region);
      return impl;
    }

    // instatiation for restart of a run  (from RegionImplFactory->deserializeRegionImpl() )
    virtual RegionImpl* deserializeRegionImpl(BundleIO& bundle, Region *region) override
    {
      // 1) instatiate the CsBindRegion which will also create the C# class <T> 
      // 2) deserialize with params from the bundle
      // 3) return the CsBindRegion class (not the C# class)
      RegionImpl* impl = new CsBindRegion(network_, nodename_, bundle, region);
      return impl;
    }

    virtual Spec* createSpec() override
    {
      return T::createSpec();
    }

  private:
    gcroot<System::String^> nodename_;
    gcroot<htm_core_cs::cs_Network^> network_;
  };


  private class CsBindRegion : public RegionImpl 
  {
  public:
    CsBindRegion(htm_core_cs::cs_Network^ cs_network, System::String^ nodename, const ValueMap& params, Region *region) : RegionImpl(region) {
      htm_core_cs::cs_RegionImpl^ cs_impl_ = cs_network->allocateRegionImpl(nodename);  // uses default constructor
      cs_impl_->setUnmanaged(this);
      htm_core_cs::cs_ValueMap^ cs_params = gcnew htm_core_cs::cs_ValueMap(params);
      cs_impl_->setValueMap(cs_params);
    }
    CsBindRegion(htm_core_cs::cs_Network^ network, System::String^ nodename, htm::BundleIO&  bundle, htm::Region *region) : RegionImpl(region) {
      cs_impl_ = network->allocateRegionImpl(nodename);  // uses default constructor
      cs_impl_->setUnmanaged(this);
      htm_core_cs::cs_BundleIO^ cs_bundle = gcnew htm_core_cs::cs_BundleIO(&bundle);
      cs_impl_->deserialize(cs_bundle);
    }

    void serialize(htm::BundleIO& bundle) { cs_impl_->serialize(gcnew htm_core_cs::cs_BundleIO(&bundle)); }
    void deserialize(htm::BundleIO& bundle) { cs_impl_->deserialize(gcnew htm_core_cs::cs_BundleIO(&bundle)); }
    void initialize() { cs_impl_->initialize(); }
    void compute() { cs_impl_->compute(); }
    std::string executeCommand(const std::vector<std::string>& args, Int64 index) {
      array<String^>^ list = gcnew array<String^>(args.size());
      for (auto i = 0; i < args.size(); i++) {
        list[i] = htm_core_cs::UTF8ToString(args[i]);
      }
      return htm_core_cs::StringToUTF8(cs_impl_->executeCommand(list, index));
    }
    size_t getNodeOutputElementCount(const std::string& outputName) {
      return cs_impl_->getNodeOutputElementCount(htm_core_cs::UTF8ToString(outputName));
    }

  private:
    gcroot<htm_core_cs::cs_RegionImpl^> cs_impl_;
  };
}  // namespace htm



namespace htm_core_cs
{
  // represents RegionImpl on the C# side of the langage interface.
  // All C# implemented Regions should subclass htm_core_cs::cs_RegionImpl.
  // 
  ref class cs_RegionImpl abstract
  {
  internal:
    cs_RegionImpl() {}
    void setUnmanaged(htm::CsBindRegion* impl) { impl_ = impl; }

  public:
    virtual ~cs_RegionImpl() { delete impl_; }
    !cs_RegionImpl() { delete impl_; }

    virtual property String^ type { String^ get() { return UTF8ToString(impl_->getType()); }}
    virtual property String^ name { String^ get() { return UTF8ToString(impl_->getName()); }}

    /* ------- Parameter support in the base class. ---------*/
    // The default implementation of all of these methods goes through
    // set/getParameterFromBuffer, which is compatible with htm 1.
    // RegionImpl subclasses may override for higher performance.

    generic <typename T>
      //    virtual property T parameter[String^, Int64] {
      T getParameter(String^ name, Int64 index) {
        System::Type^ t = T::typeid;
        if (t == System::Int32::typeid) { return region_->getParameterInt32(StringToUTF8(name), index); }
        else if (t == System::UInt32::typeid) { return region_->getParameterUInt32(StringToUTF8(name), index); }
        else if (t == System::Int64::typeid) { return region_->getParameterInt64(StringToUTF8(name), index); }
        else if (t == System::UInt64::typeid) { return region_->getParameterUInt64(StringToUTF8(name), index); }
        else if (t == System::Single::typeid) { return region_->getParameterReal32(StringToUTF8(name), index); }
        else if (t == System::Double::typeid) { return region_->getParameterReal64(StringToUTF8(name), index); }
        else if (t == System::IntPtr^::typeid) { return gcnew IntPtr(region_->getParameterHandle(StringToUTF8(name), index)); }
        else if (t == System::Boolean::typeid) { return region_->getParameterBool(StringToUTF8(name), index); }
        else if (t == System::String^::typeid) { return UTF8ToString(region_->getParameterString(StringToUTF8(name), index)); }
        else throw gcnew Exception("Invalid parameter type: " + t->Name);
      }
      generic <typename T>
        void setParameter(System::String^ name, T value) {
          System::Type^ t = T::typeid;
          if (t == System::Int32::typeid) { region_->setParameterInt32(StringToUTF8(name), value); }
          else if (t == System::UInt32::typeid) { region_->setParameterUInt32(StringToUTF8(name), value); }
          else if (t == System::Int64::typeid) { region_->setParameterInt64(StringToUTF8(name), value); }
          else if (t == System::UInt64::typeid) { region_->setParameterUInt64(StringToUTF8(name), value); }
          else if (t == System::Single::typeid) { region_->setParameterReal32(StringToUTF8(name), value); }
          else if (t == System::Double::typeid) { region_->setParameterReal64(StringToUTF8(name), value); }
          else if (t == System::IntPtr^::typeid) { region_->setParameterHandle(StringToUTF8(name), value.ToPointer()); }
          else if (t == System::Boolean::typeid) { region_->setParameterBool(StringToUTF8(name), value); }
          else if (t == System::String^::typeid) { region_->setParameterString(StringToUTF8(name), StringToUTF8(s)); }
          else throw gcnew Exception("Invalid parameter type: " + t->Name);
        }

        // virtual property array<T> parameterArray[String^, Int64]{   // returns a copy of the parameterArray
        generic <typename T>
          array<T> getParameterArray(String^ name, Int64 index) {
            // create an array in managed space to hold values.
            std::string nam = StringToUTF8(name);
            size_t count = impl_->getParameterArrayCount(nam, index);
            array<T>^ arr = gcnew array<T>(count);
            ArrayCS<T> a(arr);
            impl_->getParameterArray(nam, index, a); // copies into the managed array buffer
            return arr;
          }
          generic <typename T>
            void setParameterArray(String^ name, Int64 index, System::array<T>^ array) {
              impl_->setParameterArray(StringToUTF8(name), new ArrayCS<T>(array));
            }


            /* -------- Methods that must be implemented by subclasses -------- */

            /**
            * Can't declare a static method in an interface. But RegionFactory
            * expects to find this method. Caller gets ownership.
            */
            //static Spec* createSpec();

            // set the values from ValueMap
            virtual void setValueMap(cs_ValueMap^ params) = 0;

            // Serialize state.
            virtual void serialize(cs_BundleIO^ bundle) = 0;

            // De-serialize state. Must be called from deserializing constructor
            virtual void deserialize(cs_BundleIO^ bundle) = 0;

            /**
            * Inputs/Outputs are made available in initialize()
            * It is always called after the constructor (or load from serialized state)
            */
            virtual void initialize() = 0;

            // Compute outputs from inputs and internal state
            virtual void compute() = 0;

            // Execute a command
            virtual String^ executeCommand(array<String^>^ args, System::Int64 index) = 0;

            // Per-node size (in elements) of the given output.
            // For per-region outputs, it is the total element count.
            // This method is called only for outputs whose size is not
            // specified in the nodespec.
            virtual System::UInt64 getNodeOutputElementCount(System::String^ outputName) = 0;

            /* -------- Methods that may be overridden by subclasses -------- */
            virtual System::UInt64 getParameterArrayCount(System::String^ name, System::Int64 index) { return impl_->getParameterArrayCount(StringToUTF8(name)); }
            virtual bool isParameterShared(System::String^ name) { return impl_->isParameterShared(StringToUTF8(name)); }

  protected:
    htm::CsBindRegion* impl_;

    /* -------- Methods provided by the base class for use by subclasses -------- */

    // ---
    /// Callback for subclasses to get an output stream during serialize()
    /// (for output) and the deserializing constructor (for input)
    /// It is invalid to call this method except inside serialize() in a subclass.
    ///
    /// Only one serialization stream may be open at a time. Calling
    /// getSerializationXStream a second time automatically closes the
    /// first stream. Any open stream is closed when serialize() returns.
    // ---
    //std::ostream& getSerializationOutputStream(System::String^ name) { return impl_->getSerializationOutputStream(StringToUTF8(name));}
    //std::istream& getSerializationInputStream(System::String^ name)  { return impl_->getSerializationInputStream(StringToUTF8(name));}
    //System::String^ getSerializationPath(System::String^ name)       { return UTF8ToString(impl_->getSerializationPath(StringToUTF8(name)); }

    // These methods provide access to inputs and outputs
    // They raise an exception if the named input or output is
    // not found.
    generic<typename T>
      cs_Input<T>^ getInput(System::String^ name) { return gcnew cs_Input<T>(impl_->getInput(StringToUTF8(name))); }
    generic<typename T>
      cs_Output<T>^ getOutput(System::String^ name) { return gcnew cs_Output<T>(impl_->getOutput(StringToUTF8(name))); }

    cs_Dimensions^ getDimensions() { return gcnew cs_Dimensions(impl_->getDimensions()); }

  };





  //////////////////////////////////////
  //        Link
  //////////////////////////////////////
  ref class cs_Link
  {
  internal:
    cs_Link(Link *link) { link_ = link; own_ = false; }
  public:
    generic <typename T>
    cs_Link(String^ linkType, String^ linkParams, cs_Output<T>^ srcOutput, cs_Input<T>^ destInput, System::UInt64 propagationDelay) {
      link_ = new Link(StringToUTF8(linkType), StringToUTF8(linkParams), srcOutput->getUnmanaged(), destInput->getUnmanaged(), propagationDelay);
      own_ = true;
    }
    cs_Link(String^ linkType, String^ linkParams, String^ srcRegionName, String^ destRegionName,
      String^ srcOutputName, String^ destInputName, System::Int64 propagationDelay) {
      link_ = new Link(StringToUTF8(linkType), StringToUTF8(linkParams), StringToUTF8(srcRegionName), StringToUTF8(destRegionName),
        StringToUTF8(srcOutputName), StringToUTF8(destInputName), propagationDelay);
      own_ = true;
    }
    virtual ~cs_Link() { this->!cs_Link(); }
    !cs_Link() { if (link_ && own_) delete link_; link_ = NULL; }

    generic <typename T>
    void connectToNetwork(cs_Output<T>^ src, cs_Input<T>^ dest) { link_->connectToNetwork(src->getUnmanaged(), dest->getUnmanaged()); }
    void setSrcDimensions(cs_Dimensions^ dims) { link_->setSrcDimensions(dims->getUnmanaged()); }
    void setDestDimensions(cs_Dimensions^ dims) { link_->setDestDimensions(dims->getUnmanaged()); }
    void initialize(System::UInt64 destinationOffset) { link_->initialize(destinationOffset); }
    cs_Dimensions^ getSrcDimensions() { return gcnew cs_Dimensions(link_->getSrcDimensions()); }
    cs_Dimensions^ getDestDimensions() { return gcnew cs_Dimensions(link_->getDestDimensions()); }
    String^ getLinkType() { return UTF8ToString(link_->getLinkType()); }
    String^ getLinkParams() { return UTF8ToString(link_->getLinkParams()); }
    String^ getSrcRegionName() { return UTF8ToString(link_->getSrcRegionName()); }
    String^ getSrcOutputName() { return UTF8ToString(link_->getSrcOutputName()); }
    String^ getDestRegionName() { return UTF8ToString(link_->getDestRegionName()); }
    String^ getDestInputName() { return UTF8ToString(link_->getDestInputName()); }
    String^ getMoniker() { return UTF8ToString(link_->getMoniker()); }
    generic <typename T>
      cs_Output<T>^ getSrc() { return gcnew cs_Output<T>(link_->getSrc()); }
    generic <typename T>
      cs_Input<T>^ getDest() { return gcnew cs_Input<T>(link_->getDest()); }

    void compute() { link_->compute(); }
    //void buildSplitterMap(Input::SplitterMap& splitter)                                                          // rather than porting SplitterMap,
    generic <typename T>
      void buildSplitterMap(cs_Input<T>^ in) { link_->buildSplitterMap(in->getUnmanaged()->getSplitterMap(); }  // will this do the job?
    void shiftBufferedData() { link_->shiftBufferedData(); }
    String^ toString() { UTF8ToString(link_->toString()); }
    template <typename T>
    void serialize(cs_BundleIO^ bundle) { bundle->getostream() << link_; }

    Link* getUnmanaged() { return link_; }

  private:
    Link * link_;
    bool own_;
  };



  /////////////////////////////////////////////
  //            Input
  /////////////////////////////////////////////

  generic <typename T>
    ref class cs_Input
    {
    public:
      cs_Input(Input *input, bool own = false) { input_ = input; own_ = own; }
      cs_Input(cs_Region^ region, Boolean isRegionLevel) { input_ = new Input(region->getUnmanaged(), new ArrayCS<T>(), isRegion:Level); own_ = true; }

      virtual ~cs_Input() { if (own_) delete input_; }
      !cs_Input() { if (own_) delete input_; }
      property String^ name {
        String^ get() { return UTF8ToString(input_->getName(name)); }
        void set() { input_->setName(StringToUTF8(name)); }
      }
      void addLink(cs_Link^ link, cs_Output^ srcOutput) { input_->addLink(link->getUnmanaged(), srcOutput->getUnmanaged()); }
      cs_Link^ findLink(String^ srcRegionName, string^ srcOutputName) { return gcnew cs_Link(input_->findLink(StringToUTF8(srcRegionName), StringToUTF8(srcOutputName))); }
      void removeLink(cs_Link^ link) { input_->removeLink(link->getUnmanaged()); }
      void prepare() { input_->prepare(); }
      property array<T>^ data {
        array<T>^ get() { ArrayCS<T>& a = (ArrayCS<T>&)input_->getData(); return a->getManaged(); }
        void set(array<T>^ arr) { ArrayCS* a = new ArrayCS(arr); input_->setData(a); }
      }
      cs_Region^ getRegion() { return gcnew cs_Region(input_->getRegion()); }
      List<cs_Link^>^ getLinks() {
        List<cs_Link^>^ managedLinks = gcnew List<cs_Link^>();
        const std::vector<Link*>& links = getLinks();
        for (std::vector<Link*>::const_iterator link = links_.begin(); link != links_.end(); link++) {
          managedLinks->add(gcnew cs_link(link, false));
        }
        return managedLinks;
      }
      System::Boolean isRegionLevel() { return input_->isRegionLevel(); }
      UInt64 evaluateLinks() { return input_->evaluateLinks(); }
      void  initialize() { input_->initialize(); }
      System::Boolean isInitialized() { return input_->isInitialized(); }

    private:
      Input * input_;
      bool own_;

    };



    /////////////////////////////////////////////
    //            Output
    /////////////////////////////////////////////

    generic <typename T>
      ref class cs_Output
      {
      public:
        cs_Output(Output *output, bool own = false) { output_ = output; own_ = own; }
        cs_Output(cs_Region^ region, Boolean isRegionLevel) { output_ = new Output(region->getUnmanaged(), new ArrayCS<T>(), isRegion:Level); own_ = true; }

        virtual ~cs_Output() { if (own_) delete output_; }
        virtual !cs_Output() { if (own_) delete output_; }
        property String^ name {
          String^ get() { return UTF8ToString(output_->getName(name)); }
          void set() { output_->setName(StringToUTF8(name)); }
        }
        void  initialize() { output_->initialize(); }
        void addLink(cs_Link^ link) { output_->addLink(link->getUnmanaged()); }
        void removeLink(cs_Link^ link) { output_->removeLink(link->getUnmanaged()); }
        System::Boolean hasOutgoingLinks() { return output_->hasOutgoingLinks(); }
        property array<T>^ data {
          array<T>^ get() { ArrayCS<T>& a = (ArrayCS<T>&)output_->getData(); return a->getManaged(); }
        }
        System::Boolean isRegionLevel() { return output_->isRegionLevel(); }
        cs_Region^ getRegion() { return gcnew cs_Region(output_->getRegion()); }
        UInt64 getNodeOutputElementCount() { return output_->getNodeOutputElementCount(); }

      private:
        Output * output_;
        bool own_;
      };






      /////////////////////////////////////////////
      //            InputSpec
      /////////////////////////////////////////////

      ref class cs_InputSpec
      {
      public:
        cs_InputSpec(InputSpec *ispec) { ispec_ = ispec; }
        cs_InputSpec(
          String^ description,
          System::Int32 dataType,    // NTA_BasicType of input types
          System::UInt32 count,
          Boolean required,
          Boolean regionLevel,
          Boolean isDefaultInput,
          Boolean requireSplitterMap = true)
        {
          ispec_ = new InputSpec(StringToUTF8(d), dataType, count, required, regionLevel, isDefaultInput, requireSplitterMap);
        }

        property String^ description {
          String^ get() { return UTF8ToString(ispec_->description); }
          void set(String^ d) { ispec_->description = StringToUTF8(d); }
        }
        property System::Int32 dataType {
          System::Int32 get() { return ispec_->dataType; }
          void set(System::Int32 d) { ispec_->dataType = d; }
        }
        property System::Int32 count {
          System::Int32 get() { return ispec_->count; }
          void set(System::Int32 d) { ispec_->count = d; }
        }
        property System::Boolean required {
          Boolean get() { return ispec_->required; }
          void set(System::Boolean r) { ispec_->required = r; }
        }
        property System::Boolean regionLevel {
          Boolean get() { return ispec_->regionLevel; }
          void set(System::Boolean r) { ispec_->regionLevel = r; }
        }
        property System::Boolean isDefaultInput {
          Boolean get() { return ispec_->isDefaultInput; }
          void set(System::Boolean r) { ispec_->isDefaultInput = r; }
        }
        property System::Boolean requireSplitterMap {
          Boolean get() { return ispec_->requireSplitterMap; }
          void set(System::Boolean r) { ispec_->requireSplitterMap = r; }
        }

        InputSpec* getUnmanage() { return ispec_; }

      private:
        InputSpec * ispec_;  // this is part of the spec so this will be deleted with the spec.
      };



      /////////////////////////////////////////////
      //            OutputSpec
      /////////////////////////////////////////////
      ref class cs_OutputSpec
      {
      public:
        cs_OutputSpec(OutputSpec *ospec) { ospec_ = ospec; }
        cs_OutputSpec(String^ description, System::Int32 dataType, System::UInt64 count, Boolean regionLevel, Boolean isDefaultOutput) {
          ospec_ = new OutputSpec(StringToUTF8(description), dataType, count, regionLevel, isDefaultOutput);
        }

        property String^ description {
          String^ get() { return UTF8ToString(ospec_->description); }
          void set(String^ d) { ospec_->description = StringToUTF8(d); }
        }
        property System::Int32 dataType {       // NTA_BasicType of input types
          System::Int32 get() { return ospec_->dataType; }
          void set(System::Int32 d) { ospec_->dataType = d; }
        }
        property System::Int32 count {
          System::Int32 get() { return ospec_->count; }
          void set(System::Int32 d) { ospec_->count = d; }
        }
        property System::Boolean regionLevel {
          Boolean get() { return ospec_->regionLevel; }
          void set(System::Boolean r) { ospec_->regionLevel = r; }
        }
        property System::Boolean isDefaultOutput {
          Boolean get() { return ospec_->isDefaultOutput; }
          void set(System::Boolean r) { ospec_->isDefaultOutput = r; }
        }

      private:
        OutputSpec * ospec_;
      };

      /////////////////////////////////////////////
      //            CommandSpec
      /////////////////////////////////////////////
      ref class cs_CommandSpec
      {
      public:
        cs_CommandSpec(CommandSpec *cmd) { cmd_ = cmd; }
        cs_CommandSpec(String^ description) {
          cmd_ = new CommandSpec(StringToUTF8(description));
        }

        property String^ description {
          String^ get() { return UTF8ToString(cmd_->description); }
          void set(String^ d) { cmd_->description = StringToUTF8(d); }
        }
      private:
        CommandSpec * cmd_;
      };

      /////////////////////////////////////////////
      //            ParameterSpec
      /////////////////////////////////////////////
      //typedef htm::enum { CreateAccess, ReadOnlyAccess, ReadWriteAccess } AccessMode;

      ref class cs_ParameterSpec
      {
      public:
        cs_ParameterSpec(ParameterSpec *par) { par_ = par; }
        cs_ParameterSpec(String^ desciption, System::Int32 dataType, System::UInt64 count, String^ constraints, String^ defaultValue, htm::ParameterSpec::AccessMode accessMode) {
          par_ = new ParameterSpec( StringToUTF8(description),
                                    dataType,    // NTA_BasicType
                                    count,
                                    StringToUTF8(constraints),
                                    StringToUTF8(defaultValue),
                                    accessMode);
        }
        property String^ description {
          String^ get() { return UTF8ToString(par_->description); }
          void set(String^ d) { par_->description = StringToUTF8(d); }
        }
        property System::Int32 count {
          System::Int32 get() { return par_->count; }
          void set(System::Int32 d) { par_->count = d; }
        }
        property String^ constraints {
          String^ get() { return UTF8ToString(par_->constraints); }
          void set(String^ d) { par_->constraints = StringToUTF8(d); }
        }
        property String^ defaultValue {
          String^ get() { return UTF8ToString(par_->defaultValue); }
          void set(String^ d) { par_->defaultValue = StringToUTF8(d); }
        }
        property htm::ParameterSpec::AccessMode accessMode {
          htm::ParameterSpec::AccessMode get() { return par_->accessMode; }
          void set(htm::ParameterSpec::AccessMode d) { par_->accessMode = d; }
        }

      private:
        ParameterSpec * par_;
      };


      //////////////////////////////////////
      //        Spec
      //////////////////////////////////////
      ref class cs_Spec
      {
      internal:
        cs_Spec(const htm::Spec *spec) { spec_ = new htm::Spec(); *spec_ = *spec; own_ = true; }
      public:
        cs_Spec() {}
        virtual
          ~cs_Spec() { if (own_) delete spec_; }
        !cs_Spec() { if (own_) delete spec_; }

        String^ toString() { return UTF8ToString(spec_->toString()); }
        property System::Boolean singleNodeOnly {
          System::Boolean get() { return spec_->singleNodeOnly; }
          void set(System::Boolean v) { spec_->singleNodeOnly = v; }
        }
        property System::String^ description {
          System::String^ get() { return UTF8ToString(spec_->description); }
          void set(System::String^ v) { spec_->description = StringToUTF8(v); }
        }

        // map these parts into the spec_   TODO:  dek
        //property cs_Collection<cs_InputSpec^> inputs[System::String^]{
        //  cs_Collection<cs_InputSpec^> get(System::String^) { (&spec_->inputs); }
        //}
        //property cs_Collection<cs_OutputSpec^> outputs(&spec_->outputs);
        //property cs_Collection<cs_CommandSpec^> commands(&spec_->commands);
        //property cs_Collection<cs_ParameterSpec^>  parameters(&spec->parameters);

      private:
        htm::Spec *spec_;
        bool own_;
      };


      /////////////////////////////////////////////
      //            Dimensions
      /////////////////////////////////////////////

      ref class cs_Dimensions : public List<System::UInt64>
      {
      internal:
        cs_Dimensions(htm::Dimensions* dim) { dimensions_ = dim; }
        htm::Dimensions* getUnmanaged() { return dimensions_; }

      public:
        cs_Dimensions() { dimensions_ = new htm::Dimensions(); }
        cs_Dimensions(List<System::UInt64>^ v) { dimensions_ = new htm::Dimensions(ListTovector(v)); }
        cs_Dimensions(System::UInt64 x) { dimensions_ = new htm::Dimensions((size_t)x); }
        cs_Dimensions(System::UInt64 x, System::UInt64 y) { dimensions_ = new htm::Dimensions((size_t)x, (size_t)y); }
        cs_Dimensions(System::UInt64 x, System::UInt64 y, System::UInt64 z) { dimensions_ = new htm::Dimensions((size_t)x, (size_t)y, (size_t)z); }

        virtual
          ~cs_Dimensions() { if (dimensions_) { delete dimensions_;  dimensions_ = nullptr; } }   // destructor 
        !cs_Dimensions() { if (dimensions_) { delete dimensions_;  dimensions_ = nullptr; } }   // finalizer

        virtual property System::UInt64 count { System::UInt64 get() { return dimensions_->getCount(); }}
        virtual property System::UInt64 dimensionCount { System::UInt64 get() { return dimensions_->getDimensionCount(); }}
        virtual property System::UInt64 dimension[System::UInt64]{ System::UInt64 get(System::UInt64 index) { return dimensions_->getDimension(index); } }
        virtual property Boolean isUnspecified { Boolean get() { return dimensions_->isUnspecified(); }}
        virtual property Boolean isDontcare { Boolean get() { return dimensions_->isDontcare(); }}
        virtual property Boolean isSpecified { Boolean get() { return dimensions_->isSpecified(); } }
        virtual property Boolean isOnes { Boolean get() { return dimensions_->isOnes(); }}
        virtual property Boolean isValid { Boolean get() { return dimensions_->isValid(); }}
        virtual property System::UInt64  index[System::UInt64]{ System::UInt64 get(List<System::UInt64>^ coordinate) { return dimensions_->getIndex(ListTovector(coordinate)); } }
        virtual property List<System::UInt64>^ coordinate[System::UInt64]{ List<System::UInt64>^ get(System::UInt64 index) { return vectorToList(dimensions_->getCoordinate(index)); } }
        String^ toString() { return UTF8ToString(dimensions_->toString(true)); }
        String^ toString(Boolean humanReadable) { return UTF8ToString(dimensions_->toString(humanReadable)); }
        void promote(System::UInt64 newDimensionality) { dimensions_->promote(newDimensionality); }
        System::Boolean operator == (cs_Dimensions^ dims2) { return (&dimensions_ == &dims2->dimensions_); }
        System::Boolean operator != (cs_Dimensions^ dims2) { return (&dimensions_ != &dims2->dimensions_); }


      private:
        htm::Dimensions* dimensions_;
      };


      /////////////////////////////////////////////
      //            Collection
      /////////////////////////////////////////////
      //  This is intended to be a general container
      //  However in order to manage the wrappers we are only
      //  expecting the following C# classes to be held in a Collection.
      //     cs_OutputSpec
      //     cs_InputSpec
      //     cs_ParameterSpec
      //     cs_Commandspec
      //     cs_Region*
      //     cs_Link*
      // The objective is to retain the unmanaged collection asis without copying.

      generic <typename T>
        ref class cs_Collection
        {
        public:
          cs_Collection() { collection_ = new htm::Collection(); own = true; }
          cs_Collection(htm::Collection* collection, Boolean own = false) { collection_ = collection; own_ = own; }
          virtual ~cs_Collection() { if (own_ && collection_) delete collection_; }
          virtual !cs_Collection() { if (own_ && collection_) delete collection_; }

          UInt64 getCount() { return collection_->getCount(); }
          property String^ name[Int64]{
            String^ get(Int64 index) { const std::pair<std::string, T> pair = collection_->getByIndex(index); return UTF8ToString(pair->first()); }
          }

            // set or return the requested object.  The index can be a numerical index or the item's name. Returns Null if bad type.
            property T item[Int64]{
            T get(Int64 index) {
              if (typeid(T) == typeid(cs_OutputSpec^)) { return gcnew cs_OutputSpec((OutputSpec)collection_->getByIndex(index)->second()); }
              elseif(typeid(T) == typeid(cs_InputSpec^)) { return gcnew cs_InputSpec((InputSpec)collection_->getByIndex(index)->second()); }
              elseif(typeid(T) == typeid(cs_ParameterSpec^)) { return gcnew cs_ParameterSpec((ParameterSpec)collection_->getByIndex(index)->second()); }
              elseif(typeid(T) == typeid(cs_Commandspec^)) { return gcnew cs_Commandspec((Commandspec)collection_->getByIndex(index)->second()); }
              elseif(typeid(T) == typeid(cs_Region^)) { return gcnew cs_Region((Region*)collection_->getByIndex(index)->second()); }
              elseif(typeid(T) == typeid(cs_Link^)) { return gcnew cs_Link((Link*)collection_->getByIndex(index)->second()); }
              else return Null;
            }
            T get(String^ name) {
              if (typeid(T) == typeid(cs_OutputSpec^)) { return gcnew cs_OutputSpec((OutputSpec)collection_->getByName(name)->second()); }
              elseif(typeid(T) == typeid(cs_InputSpec^)) { return gcnew cs_InputSpec((InputSpec)collection_->getByName(name)->second()); }
              elseif(typeid(T) == typeid(cs_ParameterSpec^)) { return gcnew cs_ParameterSpec((ParameterSpec)collection_->getByName(name)->second()); }
              elseif(typeid(T) == typeid(cs_Commandspec^)) { return gcnew cs_Commandspec((Commandspec)collection_->getByName(name)->second()); }
              elseif(typeid(T) == typeid(cs_Region^)) { return gcnew cs_Region((Region*)collection_->getByName(name)->second()); }
              elseif(typeid(T) == typeid(cs_Link^)) { return gcnew cs_Link((Link*)collection_->getByName(name)->second()); }
              else return Null;
            }
            void set(String^ name, T item) { collection_->add(name, item->getUnmanaged())); }
          }
          bool contains(String^ name) { return collection_->contains(StringToUTF8(name)); }
          void remove(String^ name) { collection_->remove(StringToUTF8(name)); }

        private:
          Collection * collection_;
          bool own_;
        };

} // namespace htm_core_cs


#endif // NTA_CS_ENGINE_HPP